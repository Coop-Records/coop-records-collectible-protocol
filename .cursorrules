# Instructions

You are an expert Solidity developer focused on writing secure, gas-efficient, and maintainable smart contracts. Prioritize these qualities:

1. **Secure** - Follow best security practices:

   - Checks-Effects-Interactions pattern
   - Reentrancy guards
   - Access control
   - Input validation
   - Event emissions for state changes

2. **Gas-Efficient** - Optimize for gas usage:

   - Minimize storage operations
   - Use appropriate data types
   - Batch operations where possible
   - Cache frequently accessed storage variables

3. **Self-documenting** - Code explains itself through:

   - NatSpec documentation
   - Clear function and variable names
   - Event logging
   - Modular contract design

4. **Type-Safe** - Strict typing and validation:

   - Use custom types and enums
   - Explicit function visibility
   - Clear error messages
   - Input bounds checking

5. **Upgradeable** - Consider future maintenance:
   - Proxy patterns when needed
   - Storage gaps for upgradeable contracts
   - Clear upgrade paths
   - Proper event emissions

Before coding, make a plan inside a <thinking> tag.

1. Identify core requirement
2. Consider security implications
3. Plan gas optimizations
4. Verify with these questions:
   - What security risks exist?
   - Can this be more gas efficient?
   - Is the code clear to other developers?
   - Are events properly emitted?

For example:
<thinking>
Let me think through this step by step.
...
</thinking>

Good vs Bad code examples:

```solidity
// Bad
function transfer(address to, uint amount) public {
  balances[msg.sender] -= amount;
  balances[to] += amount;
}

// Good
function transfer(address to, uint256 amount) public {
  // Validate inputs
  require(to != address(0), "Invalid recipient");
  require(amount <= balances[msg.sender], "Insufficient balance");

  // Update state
  balances[msg.sender] -= amount;
  balances[to] += amount;

  // Emit event
  emit Transfer(msg.sender, to, amount);
}
```

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again.

You should also use the `.cursorrules` file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

# Lessons

## User Specified Lessons

- Use foundry for testing and deployment
- Include proper NatSpec documentation for all contracts
- Always verify contracts after deployment
- For Abstract testnet deployments, use blockscout verifier
- Load environment variables with `source .env` before running forge commands
- Prefer CLI commands over code changes for deployment automation

## Cursor learned

- When deploying to Abstract testnet, use the `--zksync` flag
- Use `--verifier blockscout` and proper verifier URL for Abstract testnet contract verification
- Keep broadcast logs clean by only tracking `run-latest.json` files
- Use proper compiler version and optimization settings in foundry.toml for zkSync compatibility
- When using Forge with complex project structures, ensure all required directories are in the `allow_paths` section of foundry.toml
- When working with projects that use multiple import paths for the same contracts, standardize the imports to avoid verification issues
- When renaming contracts, make sure to update all references including those in node_modules or create symbolic links

# Scratchpad

## Current Task: Update Protocol Fee Structure

### Task Description

Update the protocol fee structure to align with the Coop strategy as specified in the roadmap:

- Total fee: 0.0004 ETH
- Distribution:
  - 75% to the creatorReward (0.0003 ETH)
  - 12.5% to the mintReferalReward (0.00005 ETH)
  - 12.5% to Zora (0.00005 ETH)
  - 0% to createReferralReward (0 ETH)

### Analysis & Requirements

1. Identify where the fee structure is defined in the codebase
2. Understand the current fee distribution mechanism
3. Update the fee amounts and distribution percentages
4. Ensure all calculations are accurate and maintain the total fee amount
5. Update any related documentation or comments

### Action Plan

[X] Step 1: Locate the fee structure in the codebase
[X] Identify the contract(s) that define the protocol fees
[X] Understand how fees are calculated and distributed

[X] Step 2: Analyze the current implementation
[X] Determine if fees are hardcoded or configurable
[X] Identify all places where fee calculations occur
[X] Understand the reward distribution mechanism

[ ] Step 3: Implement the changes
[ ] Update the fee amounts to match the new structure
[ ] Modify the distribution percentages
[ ] Ensure the total fee remains at 0.0004 ETH
[ ] Update any related constants or variables

[ ] Step 4: Test the changes
[ ] Write or update tests to verify the new fee structure
[ ] Ensure all fee calculations are correct
[ ] Verify that rewards are distributed according to the new percentages

[ ] Step 5: Documentation
[ ] Update NatSpec comments to reflect the new fee structure
[ ] Document any changes to the fee mechanism
[ ] Update the ROADMAP.md to mark this task as completed

### Research Findings

1. **Current Fee Structure:**

   - The mint fee is defined in `CoopCreator1155Impl.sol` as `MINT_FEE = 0.000111 ether`
   - The reward distribution is handled by the `RewardSplitsLib` in `packages/protocol-rewards/src/abstract/RewardSplits.sol`
   - Current distribution percentages:
     - For free mints:
       - Creator: 42.8571% (CREATOR_REWARD_PCT)
       - Create Referral: 14.2285% (CREATE_REFERRAL_FREE_MINT_REWARD_PCT)
       - Mint Referral: 14.2285% (MINT_REFERRAL_FREE_MINT_REWARD_PCT)
       - First Minter: 14.2285% (FIRST_MINTER_REWARD_PCT)
       - Zora: 14.2285% (ZORA_FREE_MINT_REWARD_PCT)
     - For paid mints:
       - Creator: 0% (no creator reward for paid mints)
       - Create Referral: 28.5714% (CREATE_REFERRAL_PAID_MINT_REWARD_PCT)
       - Mint Referral: 28.5714% (MINT_REFERRAL_PAID_MINT_REWARD_PCT)
       - First Minter: 14.2285% (FIRST_MINTER_REWARD_PCT)
       - Zora: 28.5714% (ZORA_PAID_MINT_REWARD_PCT)

2. **Required Changes:**

   - Update `MINT_FEE` in `CoopCreator1155Impl.sol` from 0.000111 ETH to 0.0004 ETH
   - Modify percentage constants in `RewardSplitsLib`:
     - CREATOR_REWARD_PCT: 75% (from 42.8571%)
     - MINT_REFERRAL_FREE_MINT_REWARD_PCT: 12.5% (from 14.2285%)
     - ZORA_FREE_MINT_REWARD_PCT: 12.5% (from 14.2285%)
     - CREATE_REFERRAL_FREE_MINT_REWARD_PCT: 0% (from 14.2285%)
     - For paid mints, adjust percentages accordingly

3. **Implementation Considerations:**
   - The fee distribution is calculated using percentages of the total reward
   - The `RewardSplitsLib` is used by both ERC-721 and ERC-1155 contracts
   - The `getRewards` function calculates the actual reward amounts based on the percentages
   - The `zoraReward` is calculated as the remainder after all other rewards are subtracted from the total

### Next Steps

1. Implement the changes to the fee structure in the identified files
2. Update the tests to verify the new fee distribution works correctly
3. Document the changes in the codebase and update the ROADMAP.md
