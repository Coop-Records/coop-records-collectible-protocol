# Instructions

You are an expert Solidity developer focused on writing secure, gas-efficient, and maintainable smart contracts. Prioritize these qualities:

1. **Secure** - Follow best security practices:

   - Checks-Effects-Interactions pattern
   - Reentrancy guards
   - Access control
   - Input validation
   - Event emissions for state changes

2. **Gas-Efficient** - Optimize for gas usage:

   - Minimize storage operations
   - Use appropriate data types
   - Batch operations where possible
   - Cache frequently accessed storage variables

3. **Self-documenting** - Code explains itself through:

   - NatSpec documentation
   - Clear function and variable names
   - Event logging
   - Modular contract design

4. **Type-Safe** - Strict typing and validation:

   - Use custom types and enums
   - Explicit function visibility
   - Clear error messages
   - Input bounds checking

5. **Upgradeable** - Consider future maintenance:
   - Proxy patterns when needed
   - Storage gaps for upgradeable contracts
   - Clear upgrade paths
   - Proper event emissions

Before coding, make a plan inside a <thinking> tag.

1. Identify core requirement
2. Consider security implications
3. Plan gas optimizations
4. Verify with these questions:
   - What security risks exist?
   - Can this be more gas efficient?
   - Is the code clear to other developers?
   - Are events properly emitted?

For example:
<thinking>
Let me think through this step by step.
...
</thinking>

Good vs Bad code examples:

```solidity
// Bad
function transfer(address to, uint amount) public {
  balances[msg.sender] -= amount;
  balances[to] += amount;
}

// Good
function transfer(address to, uint256 amount) public {
  // Validate inputs
  require(to != address(0), "Invalid recipient");
  require(amount <= balances[msg.sender], "Insufficient balance");

  // Update state
  balances[msg.sender] -= amount;
  balances[to] += amount;

  // Emit event
  emit Transfer(msg.sender, to, amount);
}
```

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again.

You should also use the `.cursorrules` file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

# Lessons

## User Specified Lessons

- Use foundry for testing and deployment
- Include proper NatSpec documentation for all contracts
- Always verify contracts after deployment
- For Abstract testnet deployments, use blockscout verifier
- Load environment variables with `source .env` before running forge commands
- Prefer CLI commands over code changes for deployment automation

## Cursor learned

- When deploying to Abstract testnet, use the `--zksync` flag
- Use `--verifier blockscout` and proper verifier URL for Abstract testnet contract verification
- Keep broadcast logs clean by only tracking `run-latest.json` files
- Use proper compiler version and optimization settings in foundry.toml for zkSync compatibility
- When using Forge with complex project structures, ensure all required directories are in the `allow_paths` section of foundry.toml
- When working with projects that use multiple import paths for the same contracts, standardize the imports to avoid verification issues
- When renaming contracts, make sure to update all references including those in node_modules or create symbolic links
- When updating protocol fee structures, ensure all percentage calculations are accurate and maintain the total fee amount

# Scratchpad

## Current Task: Refactor ZoraCreator1155FactoryImpl to CoopCreator1155FactoryImpl

### Task Description

From the roadmap (step 5):

- Actual: name is ZoraCreator1155FactoryImpl
- Required: name is CoopCreator1155FactoryImpl

This task involves renaming the ZoraCreator1155FactoryImpl contract to CoopCreator1155FactoryImpl, ensuring all references to this contract are updated throughout the codebase.

### Action Plan

[X] Step 1: Locate the ZoraCreator1155FactoryImpl contract
[X] Find the file containing the contract definition
[X] Understand the contract's role in the system

[X] Step 2: Analyze dependencies and references
[X] Identify all imports of ZoraCreator1155FactoryImpl
[X] Identify all places where the contract is instantiated or referenced
[X] Check for any interfaces or abstract contracts that might need updating

[ ] Step 3: Implement the changes
[ ] Create a new file for CoopCreator1155FactoryImpl
[ ] Copy the content from ZoraCreator1155FactoryImpl and update the contract name
[ ] Update the contract name in the definition
[ ] Update the contractName() function to return "COOP 1155 Contract Factory"
[ ] Update any references to the contract name in comments or documentation

[ ] Step 4: Update references in other files
[ ] Update import statements in all files that import ZoraCreator1155FactoryImpl
[ ] Update any instantiations or references to ZoraCreator1155FactoryImpl
[ ] Update deployment scripts that reference ZoraCreator1155FactoryImpl

[ ] Step 5: Test the changes
[ ] Run the test suite to ensure functionality is preserved
[ ] Check for any compilation errors or warnings
[ ] Verify that the contract works as expected with the new name

[ ] Step 6: Documentation
[ ] Update any documentation referencing the old contract name
[ ] Update the ROADMAP.md to mark this task as completed

### Implementation Considerations

1. **Naming Consistency**: Ensure the naming is consistent with other refactored contracts (e.g., CoopCreator1155Impl).
2. **Import Paths**: Be careful with import paths, especially in node_modules or other packages.
3. **Interface Compatibility**: If there are interfaces for this contract, they need to be updated as well.
4. **Event Signatures**: If the contract emits events, renaming might affect event signatures.
5. **Deployment Scripts**: Check if there are deployment scripts that reference this contract.

### Findings

1. The ZoraCreator1155FactoryImpl contract is defined in `packages/1155-contracts/src/factory/ZoraCreator1155FactoryImpl.sol`.
2. The contract is a factory for creating new ZoraCreator1155 contracts.
3. It implements the IZoraCreator1155Factory interface.
4. The contract is referenced in multiple files across the codebase, including test files, deployment scripts, and other contracts.
5. The contract is used in the deployment process through the ZoraDeployerUtils.sol file.
6. The contract's contractName() function currently returns "COOP 1155 Contract Factory", which is already updated.
7. The contract is used in the subgraph for indexing events.

### Next Steps

1. Create a new file for CoopCreator1155FactoryImpl
2. Copy the content from ZoraCreator1155FactoryImpl and update the contract name
3. Update references in other files
4. Test the changes
5. Update documentation
